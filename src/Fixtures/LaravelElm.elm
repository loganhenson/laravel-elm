port module LaravelElm exposing (Errors, Scroll, Viewports, decodeErrors, decodeViewports, page, preserveScroll, receiveNewProps, saveScroll, sendScroll, setViewports)

-- Do not edit this file manually.

import Browser
import Browser.Dom exposing (setViewportOf)
import Dict exposing (Dict)
import Html exposing (Html, pre, text)
import Html.Attributes exposing (id)
import Html.Events exposing (on)
import Json.Decode exposing (Decoder, Error, decodeValue, dict, errorToString, float, list, string)
import Json.Decode.Pipeline exposing (hardcoded, required, requiredAt)
import Json.Encode exposing (Value)
import Task


port receiveNewProps : (Value -> msg) -> Sub msg


port sendScroll : Value -> Cmd msg


port sendState : Value -> Cmd msg


type alias Scroll =
    { key : String, x : Float, y : Float }


type alias Errors =
    Dict String (List String)


type alias Viewport =
    { x : Float, y : Float }


type alias Viewports =
    Dict String Viewport


page :
    { decodeProps : Decoder props
    , stateFromProps : props -> state
    , encodeState : state -> Value
    , view : { props : props, state : state } -> Html msg
    , update : msg -> { props : props, state : state } -> ( { props : props, state : state }, Cmd msg )
    , subscriptions : Result Error { props : props, state : state } -> Sub msg
    , onMount : props -> Cmd msg
    }
    -> Program Value (Result Error { props : props, state : state }) msg
page { decodeProps, stateFromProps, encodeState, view, update, subscriptions, onMount } =
    Browser.element
        { init =
            \json ->
                let
                    decodedProps =
                        decodeValue decodeProps json
                in
                case decodedProps of
                    Ok props ->
                        ( Ok { props = props, state = stateFromProps props }, onMount props )

                    Err error ->
                        ( Err error, Cmd.none )
        , view =
            \resultModel ->
                case resultModel of
                    Ok model ->
                        view model

                    Err error ->
                        pre [] [ text <| errorToString error ]
        , update =
            \msg resultModel ->
                case resultModel of
                    Ok model ->
                        let
                            ( newModel, cmd ) =
                                update msg model
                        in
                        ( Ok newModel
                        , Cmd.batch
                            [ cmd
                            , case model.state /= newModel.state of
                                True ->
                                    let
                                        prevEncodedState =
                                            encodeState model.state

                                        encodedState =
                                            encodeState newModel.state
                                    in
                                    case prevEncodedState /= encodedState of
                                        True ->
                                            sendState <| encodeState newModel.state

                                        False ->
                                            Cmd.none

                                False ->
                                    Cmd.none
                            ]
                        )

                    Err error ->
                        ( Err error, Cmd.none )
        , subscriptions = subscriptions
        }


updateComponent :
    { componentMsg : componentMsg
    , componentUpdate : componentMsg -> componentModel -> ( componentModel, Cmd componentMsg )
    , componentModel : componentModel
    , pageComponentMsg : componentMsg -> pageMsg
    , setter : componentModel -> { props : props, state : state }
    }
    -> ( { props : props, state : state }, Cmd pageMsg )
updateComponent { componentMsg, componentUpdate, componentModel, pageComponentMsg, setter } =
    componentUpdate componentMsg componentModel
        |> Tuple.mapBoth setter (Cmd.map pageComponentMsg)


decodeViewport : Decoder Viewport
decodeViewport =
    Json.Decode.succeed Viewport
        |> required "x" float
        |> required "y" float


decodeViewports : Decoder Viewports
decodeViewports =
    dict decodeViewport


decodeErrors : Decoder Errors
decodeErrors =
    dict (list string)


setViewports : msg -> Viewports -> Cmd msg
setViewports msg viewports =
    Cmd.batch
        (List.map
            (\( key, { x, y } ) ->
                Task.attempt
                    (\_ -> msg)
                    (setViewportOf key x y)
            )
            (Dict.toList viewports)
        )


decodeScroll : String -> (Scroll -> msg) -> Json.Decode.Decoder msg
decodeScroll key msg =
    Json.Decode.map msg
        (Json.Decode.succeed Scroll
            |> hardcoded key
            |> requiredAt [ "target", "scrollLeft" ] float
            |> requiredAt [ "target", "scrollTop" ] float
        )


preserveScroll : (Scroll -> msg) -> String -> List (Html.Attribute msg)
preserveScroll msg key =
    [ on "scroll" (decodeScroll key msg), id key ]


saveScroll : Scroll -> Cmd msg
saveScroll scroll =
    sendScroll <|
        Json.Encode.object
            [ ( "key", Json.Encode.string scroll.key )
            , ( "x", Json.Encode.float scroll.x )
            , ( "y", Json.Encode.float scroll.y )
            ]
